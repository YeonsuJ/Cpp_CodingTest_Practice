## 문제 설명
1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)

## 제한 조건
- n은 2이상 1000000이하의 자연수입니다.

## 입출력 예
|n|result|
|---|---|
|10|4|
|5|3|

## 입출력 예 설명
입출력 예 #1
- 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

입출력 예 #2
- 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환

## 풀이 1
<details>
  <summary>펼치기 </summary>

```cpp
#include <vector>

using namespace std;

int solution(int n) {
    int answer = 0;
    
    // char는 1바이트(8비트)를 사용하며, 일반적인 배열처럼 동작함
    // 1은 true(소수임), 0은 false(소수 아님)를 의미하도록 설정
    vector<char> isPrime(n + 1, 1); 

    isPrime[0] = isPrime[1] = 0;

    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            // i가 소수라면, i의 배수들을 모두 0으로 처리
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = 0;
            }
        }
    }

    // 소수(1)의 개수 카운트
    for (int i = 2; i <= n; i++) {
        if (isPrime[i] == 1) {
            answer++;
        }
    }

    return answer;

    // 소수(1)의 개수 카운트 (algorithm 헤더사용 시)
    //return count(isPrime.begin() + 2, isPrime.end(), 1);
}
```
</details>

## 접근 및 배운점
- 에라토스테네스의 체 구현
- 1000000이하의 자연수라는 제한조건, 효율성 테스트
- 정수 기반 루프 조건 최적화
  - i * i <= n 조건을 사용하여 부동 소수점 오차가 발생할 수 있는 sqrt() 함수 없이 정수 연산만으로 효율적인 탐색 범위를 설정함
  (정수 연산 방식은 부동 소수점 연산 유닛(FPU)이 없거나 성능이 제한적인 임베디드 환경(MCU)에서 안정적이고 효율적인 접근 방식)
- 중복 제거 알고리즘
  - 안쪽 루프를 j = i * i부터 시작하여, 이미 이전 단계(2, 3의 배수 등)에서 걸러진 합성수들에 대한 중복 연산을 방지함
- 메모리 최적화
  - `vector<char>`를 쓰면 int보다 메모리를 1/4로 줄일 수 있음

  - 왜 `vector<bool>`이 아닌가?
    - C++에서 vector<bool>은 공간 최적화를 위해 1비트당 하나의 값을 저장하도록 특수화되어 있음
    - 하지만 비트 단위 조작을 위한 추가 연산이 필요하며, 엄밀히 말해 STL 컨테이너의 요구사항을 완벽히 충족하지 않아 예기치 못한 동작이나 성능 저하가 발생할 수 있음
