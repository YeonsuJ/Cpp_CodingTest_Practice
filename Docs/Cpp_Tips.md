? [실버 상위 / Lv2 / Lv3 초반] 맞춤형 커리큘럼
1. 필수 마스터 (이걸 못 풀면 합격하기 힘듦)
이 영역은 문제만 보고 바로 코드가 나올 정도로 연습해야 하는 Lv2의 기본기입니다.

[ ] 구현 / 시뮬레이션 (가장 중요)

설명: 배열 돌리기, 문자열 파싱, 복잡한 조건 분기 처리.

[ ] BFS / DFS (그래프 탐색) (가장 중요)

범위: 미로 찾기, 영역 넓이 구하기, 연결 요소 개수 세기.

주의: 백트래킹(재귀)도 여기서 기본은 다져야 함.

[ ] 스택 / 큐

범위: 짝 맞추기, 프로세스 스케줄링.

[ ] 해시 (Hash / Map / Set)

범위: 중복 제거, 빈도수 세기, 빠른 검색 (O(1)).

[ ] 정렬 (Sorting)

범위: 커스텀 정렬 (조건이 여러 개일 때의 정렬).

2. 고득점 & Lv3 진입 (합격의 열쇠)
실버 상위권과 Lv3 초반 문제에서 변별력을 가르는 유형입니다. 여기서 막히는 경우가 많으니 집중 공략이 필요합니다.

[ ] 이분 탐색 (Binary Search) (필수 추가)

*목표: UP/DOWN 숫자 맞추기 개념을 넘어, **'파라메트릭 서치(최적값 찾기)'*까지.

예시: 입국심사(Lv3), 예산 배정 등.

[ ] 우선순위 큐 & 힙 (Heap) (필수 추가)

목표: 다익스트라 기본 혹은 데이터를 계속 넣으면서 최댓값/최솟값만 쏙쏙 빼내야 할 때.

예시: 더 맵게(Lv2), 디스크 컨트롤러(Lv3).

[ ] 그리디 (Greedy)

목표: 현재 상황에서 최선의 선택을 하는 로직 증명.

예시: 조이스틱, 단속카메라.

[ ] 동적 계획법 (DP) - 기초

목표: 점화식 세우기. 배낭 문제(Knapsack) 같은 심화보다는 피보나치, 타일링, 정수 삼각형 수준.

[ ] 투 포인터 & 슬라이딩 윈도우 (필수 추가)

목표: O(N^2)을 O(N)으로 줄이는 테크닉. 배열의 부분 합이나 특정 조건을 만족하는 구간 찾기.

3. 가성비 전략 (알아두면 좋은 무기)
빈출도는 조금 낮지만, 알면 코드가 획기적으로 짧아지거나 Lv3 초반 쉬운 문제를 날로 먹을 수 있는 알고리즘입니다.

[ ] 최단 경로 - 다익스트라 (Dijkstra) (필수 추가)

딱 여기까지만: 복잡한 응용보다는 'A에서 B로 가는 최소 비용' 기본 코드 암기.

[ ] 유니온 파인드 (Union-Find) (추가)

용도: '네트워크 연결' 같은 문제에서 그룹을 짓거나 연결 여부 확인.

[ ] 그래프 - 트리 순회

용도: 트리의 부모 찾기, 깊이 구하기 정도의 기본 연산.

---

? 학습 전략 가이드
이 커리큘럼대로라면 공부 순서는 이렇게 잡으시는 게 가장 효율적입니다.

자료구조 4대장: 스택, 큐, 해시, 힙 (라이브러리 사용법 완벽 숙지)

구현 & 완전탐색: BFS/DFS와 시뮬레이션 문제 양치기 (여기가 단단해야 함)

효율성 뚫기: 이분 탐색, 투 포인터, 그리디 패턴 익히기

---


?? C++ 사용 시 주의할 점 (목표 레벨 기준)
백준 실버/프로그래머스 Lv2 구간에서 C++ 사용자가 자주 겪는 상황입니다.

1. cin, cout 속도 문제 (시간 초과 방지) C++의 입출력은 기본적으로 느립니다. main 함수 시작 부분에 무조건 아래 3줄을 넣는 것을 습관화하세요. (백준 필수)

C++

ios::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
2. 문자열 처리 (Python보다 어려움) Python은 split() 한 방이면 되지만, C++은 문자열 자르기가 번거롭습니다.

stringstream을 이용하거나,

간단한 파싱 로직을 직접 구현해야 할 때가 많습니다. (Lv2 문자열 문제에서 중요)

3. long long 사용 문제 조건에서 "숫자가 10억, 20억을 넘어간다" 싶으면 int 대신 무조건 long long을 쓰세요. (자주 하는 실수 1위)

4. bits/stdc++.h (만능 헤더) 코딩 테스트 환경(GCC 컴파일러)에서는 #include <bits/stdc++.h> 한 줄이면 위의 모든 헤더가 포함됩니다. (프로그래머스, 백준 모두 지원)

실무에서는 쓰면 안 되지만, 코딩 테스트에서는 시간 단축을 위해 애용합니다.

? C++ 사용자로서의 장점
이 커리큘럼을 C++로 준비하시면 속도(Performance) 면에서 엄청난 이득을 봅니다.

Python 사용자가 "시간 초과"로 고생할 때, C++ 사용자는 비효율적으로 짜도 그냥 통과되는 경우가 많습니다. (특히 백준)

std::map이나 priority_queue가 매우 강력하게 최적화되어 있습니다.